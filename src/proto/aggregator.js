"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: aggregator.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregatorClient = exports.AggregatorService = exports.XploreResponse = exports.RouteStep = exports.Step = exports.APISwapResponse = exports.XploreRequest = exports.SuiTransactionData = exports.SolanaTransactionData = exports.EvmTransactionData = exports.SwapResponse = exports.TransactionData = exports.SwapRequest = exports.TransactionRecord = exports.TransactionRecordRequest = exports.ChainToken = exports.TransactionStatus = exports.protobufPackage = void 0;
exports.transactionStatusFromJSON = transactionStatusFromJSON;
exports.transactionStatusToJSON = transactionStatusToJSON;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const grpc_js_1 = require("@grpc/grpc-js");
exports.protobufPackage = "xplore";
/** Status of the transaction */
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus[TransactionStatus["UNKNOWN"] = 0] = "UNKNOWN";
    TransactionStatus[TransactionStatus["PENDING"] = 1] = "PENDING";
    TransactionStatus[TransactionStatus["COMPLETED"] = 2] = "COMPLETED";
    TransactionStatus[TransactionStatus["FAILED"] = 3] = "FAILED";
    TransactionStatus[TransactionStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));
function transactionStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return TransactionStatus.UNKNOWN;
        case 1:
        case "PENDING":
            return TransactionStatus.PENDING;
        case 2:
        case "COMPLETED":
            return TransactionStatus.COMPLETED;
        case 3:
        case "FAILED":
            return TransactionStatus.FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TransactionStatus.UNRECOGNIZED;
    }
}
function transactionStatusToJSON(object) {
    switch (object) {
        case TransactionStatus.UNKNOWN:
            return "UNKNOWN";
        case TransactionStatus.PENDING:
            return "PENDING";
        case TransactionStatus.COMPLETED:
            return "COMPLETED";
        case TransactionStatus.FAILED:
            return "FAILED";
        case TransactionStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseChainToken() {
    return { chainId: "", address: "", isNative: undefined };
}
exports.ChainToken = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.chainId !== "") {
            writer.uint32(10).string(message.chainId);
        }
        if (message.address !== "") {
            writer.uint32(18).string(message.address);
        }
        if (message.isNative !== undefined) {
            writer.uint32(24).bool(message.isNative);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.chainId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.isNative = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
            address: isSet(object.address) ? globalThis.String(object.address) : "",
            isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.chainId !== "") {
            obj.chainId = message.chainId;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.isNative !== undefined) {
            obj.isNative = message.isNative;
        }
        return obj;
    },
    create(base) {
        return exports.ChainToken.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseChainToken();
        message.chainId = (_a = object.chainId) !== null && _a !== void 0 ? _a : "";
        message.address = (_b = object.address) !== null && _b !== void 0 ? _b : "";
        message.isNative = (_c = object.isNative) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseTransactionRecordRequest() {
    return { transactionHash: "" };
}
exports.TransactionRecordRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.transactionHash !== "") {
            writer.uint32(10).string(message.transactionHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionRecordRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transactionHash = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { transactionHash: isSet(object.transactionHash) ? globalThis.String(object.transactionHash) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.transactionHash !== "") {
            obj.transactionHash = message.transactionHash;
        }
        return obj;
    },
    create(base) {
        return exports.TransactionRecordRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseTransactionRecordRequest();
        message.transactionHash = (_a = object.transactionHash) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseTransactionRecord() {
    return {
        sourceTransactionHash: "",
        destinationTransactionHash: "",
        sourceTimestamp: 0,
        destinationTimestamp: 0,
        node: "",
        sender: "",
        amountIn: "",
        inputToken: undefined,
        outputToken: undefined,
        amountOut: "",
        recipientAddress: "",
        status: 0,
    };
}
exports.TransactionRecord = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.sourceTransactionHash !== "") {
            writer.uint32(10).string(message.sourceTransactionHash);
        }
        if (message.destinationTransactionHash !== "") {
            writer.uint32(18).string(message.destinationTransactionHash);
        }
        if (message.sourceTimestamp !== 0) {
            writer.uint32(24).uint64(message.sourceTimestamp);
        }
        if (message.destinationTimestamp !== 0) {
            writer.uint32(32).uint64(message.destinationTimestamp);
        }
        if (message.node !== "") {
            writer.uint32(42).string(message.node);
        }
        if (message.sender !== "") {
            writer.uint32(50).string(message.sender);
        }
        if (message.amountIn !== "") {
            writer.uint32(58).string(message.amountIn);
        }
        if (message.inputToken !== undefined) {
            exports.ChainToken.encode(message.inputToken, writer.uint32(66).fork()).join();
        }
        if (message.outputToken !== undefined) {
            exports.ChainToken.encode(message.outputToken, writer.uint32(74).fork()).join();
        }
        if (message.amountOut !== "") {
            writer.uint32(82).string(message.amountOut);
        }
        if (message.recipientAddress !== "") {
            writer.uint32(90).string(message.recipientAddress);
        }
        if (message.status !== 0) {
            writer.uint32(96).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.sourceTransactionHash = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.destinationTransactionHash = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.sourceTimestamp = longToNumber(reader.uint64());
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.destinationTimestamp = longToNumber(reader.uint64());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.node = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.amountIn = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.inputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.outputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.amountOut = reader.string();
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.recipientAddress = reader.string();
                    continue;
                }
                case 12: {
                    if (tag !== 96) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sourceTransactionHash: isSet(object.sourceTransactionHash) ? globalThis.String(object.sourceTransactionHash) : "",
            destinationTransactionHash: isSet(object.destinationTransactionHash)
                ? globalThis.String(object.destinationTransactionHash)
                : "",
            sourceTimestamp: isSet(object.sourceTimestamp) ? globalThis.Number(object.sourceTimestamp) : 0,
            destinationTimestamp: isSet(object.destinationTimestamp) ? globalThis.Number(object.destinationTimestamp) : 0,
            node: isSet(object.node) ? globalThis.String(object.node) : "",
            sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
            amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
            inputToken: isSet(object.inputToken) ? exports.ChainToken.fromJSON(object.inputToken) : undefined,
            outputToken: isSet(object.outputToken) ? exports.ChainToken.fromJSON(object.outputToken) : undefined,
            amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
            recipientAddress: isSet(object.recipientAddress) ? globalThis.String(object.recipientAddress) : "",
            status: isSet(object.status) ? transactionStatusFromJSON(object.status) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sourceTransactionHash !== "") {
            obj.sourceTransactionHash = message.sourceTransactionHash;
        }
        if (message.destinationTransactionHash !== "") {
            obj.destinationTransactionHash = message.destinationTransactionHash;
        }
        if (message.sourceTimestamp !== 0) {
            obj.sourceTimestamp = Math.round(message.sourceTimestamp);
        }
        if (message.destinationTimestamp !== 0) {
            obj.destinationTimestamp = Math.round(message.destinationTimestamp);
        }
        if (message.node !== "") {
            obj.node = message.node;
        }
        if (message.sender !== "") {
            obj.sender = message.sender;
        }
        if (message.amountIn !== "") {
            obj.amountIn = message.amountIn;
        }
        if (message.inputToken !== undefined) {
            obj.inputToken = exports.ChainToken.toJSON(message.inputToken);
        }
        if (message.outputToken !== undefined) {
            obj.outputToken = exports.ChainToken.toJSON(message.outputToken);
        }
        if (message.amountOut !== "") {
            obj.amountOut = message.amountOut;
        }
        if (message.recipientAddress !== "") {
            obj.recipientAddress = message.recipientAddress;
        }
        if (message.status !== 0) {
            obj.status = transactionStatusToJSON(message.status);
        }
        return obj;
    },
    create(base) {
        return exports.TransactionRecord.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseTransactionRecord();
        message.sourceTransactionHash = (_a = object.sourceTransactionHash) !== null && _a !== void 0 ? _a : "";
        message.destinationTransactionHash = (_b = object.destinationTransactionHash) !== null && _b !== void 0 ? _b : "";
        message.sourceTimestamp = (_c = object.sourceTimestamp) !== null && _c !== void 0 ? _c : 0;
        message.destinationTimestamp = (_d = object.destinationTimestamp) !== null && _d !== void 0 ? _d : 0;
        message.node = (_e = object.node) !== null && _e !== void 0 ? _e : "";
        message.sender = (_f = object.sender) !== null && _f !== void 0 ? _f : "";
        message.amountIn = (_g = object.amountIn) !== null && _g !== void 0 ? _g : "";
        message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
            ? exports.ChainToken.fromPartial(object.inputToken)
            : undefined;
        message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
            ? exports.ChainToken.fromPartial(object.outputToken)
            : undefined;
        message.amountOut = (_h = object.amountOut) !== null && _h !== void 0 ? _h : "";
        message.recipientAddress = (_j = object.recipientAddress) !== null && _j !== void 0 ? _j : "";
        message.status = (_k = object.status) !== null && _k !== void 0 ? _k : 0;
        return message;
    },
};
function createBaseSwapRequest() {
    return {
        inputToken: undefined,
        outputToken: undefined,
        amountIn: "",
        amountOutMin: "",
        slippageTolerancePercent: 0,
        recipientAddress: "",
        senderAddress: "",
        exactOut: false,
        timeoutMs: 0,
        generateDepositAddress: false,
    };
}
exports.SwapRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.inputToken !== undefined) {
            exports.ChainToken.encode(message.inputToken, writer.uint32(10).fork()).join();
        }
        if (message.outputToken !== undefined) {
            exports.ChainToken.encode(message.outputToken, writer.uint32(18).fork()).join();
        }
        if (message.amountIn !== "") {
            writer.uint32(26).string(message.amountIn);
        }
        if (message.amountOutMin !== "") {
            writer.uint32(34).string(message.amountOutMin);
        }
        if (message.slippageTolerancePercent !== 0) {
            writer.uint32(40).uint64(message.slippageTolerancePercent);
        }
        if (message.recipientAddress !== "") {
            writer.uint32(50).string(message.recipientAddress);
        }
        if (message.senderAddress !== "") {
            writer.uint32(58).string(message.senderAddress);
        }
        if (message.exactOut !== false) {
            writer.uint32(64).bool(message.exactOut);
        }
        if (message.timeoutMs !== 0) {
            writer.uint32(72).int64(message.timeoutMs);
        }
        if (message.generateDepositAddress !== false) {
            writer.uint32(80).bool(message.generateDepositAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwapRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.inputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.outputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.amountIn = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.amountOutMin = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.slippageTolerancePercent = longToNumber(reader.uint64());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.recipientAddress = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.senderAddress = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.exactOut = reader.bool();
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.timeoutMs = longToNumber(reader.int64());
                    continue;
                }
                case 10: {
                    if (tag !== 80) {
                        break;
                    }
                    message.generateDepositAddress = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            inputToken: isSet(object.inputToken) ? exports.ChainToken.fromJSON(object.inputToken) : undefined,
            outputToken: isSet(object.outputToken) ? exports.ChainToken.fromJSON(object.outputToken) : undefined,
            amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
            amountOutMin: isSet(object.amountOutMin) ? globalThis.String(object.amountOutMin) : "",
            slippageTolerancePercent: isSet(object.slippageTolerancePercent)
                ? globalThis.Number(object.slippageTolerancePercent)
                : 0,
            recipientAddress: isSet(object.recipientAddress) ? globalThis.String(object.recipientAddress) : "",
            senderAddress: isSet(object.senderAddress) ? globalThis.String(object.senderAddress) : "",
            exactOut: isSet(object.exactOut) ? globalThis.Boolean(object.exactOut) : false,
            timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
            generateDepositAddress: isSet(object.generateDepositAddress)
                ? globalThis.Boolean(object.generateDepositAddress)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.inputToken !== undefined) {
            obj.inputToken = exports.ChainToken.toJSON(message.inputToken);
        }
        if (message.outputToken !== undefined) {
            obj.outputToken = exports.ChainToken.toJSON(message.outputToken);
        }
        if (message.amountIn !== "") {
            obj.amountIn = message.amountIn;
        }
        if (message.amountOutMin !== "") {
            obj.amountOutMin = message.amountOutMin;
        }
        if (message.slippageTolerancePercent !== 0) {
            obj.slippageTolerancePercent = Math.round(message.slippageTolerancePercent);
        }
        if (message.recipientAddress !== "") {
            obj.recipientAddress = message.recipientAddress;
        }
        if (message.senderAddress !== "") {
            obj.senderAddress = message.senderAddress;
        }
        if (message.exactOut !== false) {
            obj.exactOut = message.exactOut;
        }
        if (message.timeoutMs !== 0) {
            obj.timeoutMs = Math.round(message.timeoutMs);
        }
        if (message.generateDepositAddress !== false) {
            obj.generateDepositAddress = message.generateDepositAddress;
        }
        return obj;
    },
    create(base) {
        return exports.SwapRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseSwapRequest();
        message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
            ? exports.ChainToken.fromPartial(object.inputToken)
            : undefined;
        message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
            ? exports.ChainToken.fromPartial(object.outputToken)
            : undefined;
        message.amountIn = (_a = object.amountIn) !== null && _a !== void 0 ? _a : "";
        message.amountOutMin = (_b = object.amountOutMin) !== null && _b !== void 0 ? _b : "";
        message.slippageTolerancePercent = (_c = object.slippageTolerancePercent) !== null && _c !== void 0 ? _c : 0;
        message.recipientAddress = (_d = object.recipientAddress) !== null && _d !== void 0 ? _d : "";
        message.senderAddress = (_e = object.senderAddress) !== null && _e !== void 0 ? _e : "";
        message.exactOut = (_f = object.exactOut) !== null && _f !== void 0 ? _f : false;
        message.timeoutMs = (_g = object.timeoutMs) !== null && _g !== void 0 ? _g : 0;
        message.generateDepositAddress = (_h = object.generateDepositAddress) !== null && _h !== void 0 ? _h : false;
        return message;
    },
};
function createBaseTransactionData() {
    return { evmData: undefined, solanaData: undefined, suiData: undefined };
}
exports.TransactionData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.evmData !== undefined) {
            exports.EvmTransactionData.encode(message.evmData, writer.uint32(10).fork()).join();
        }
        if (message.solanaData !== undefined) {
            exports.SolanaTransactionData.encode(message.solanaData, writer.uint32(18).fork()).join();
        }
        if (message.suiData !== undefined) {
            exports.SuiTransactionData.encode(message.suiData, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.evmData = exports.EvmTransactionData.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.solanaData = exports.SolanaTransactionData.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.suiData = exports.SuiTransactionData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            evmData: isSet(object.evmData) ? exports.EvmTransactionData.fromJSON(object.evmData) : undefined,
            solanaData: isSet(object.solanaData) ? exports.SolanaTransactionData.fromJSON(object.solanaData) : undefined,
            suiData: isSet(object.suiData) ? exports.SuiTransactionData.fromJSON(object.suiData) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.evmData !== undefined) {
            obj.evmData = exports.EvmTransactionData.toJSON(message.evmData);
        }
        if (message.solanaData !== undefined) {
            obj.solanaData = exports.SolanaTransactionData.toJSON(message.solanaData);
        }
        if (message.suiData !== undefined) {
            obj.suiData = exports.SuiTransactionData.toJSON(message.suiData);
        }
        return obj;
    },
    create(base) {
        return exports.TransactionData.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseTransactionData();
        message.evmData = (object.evmData !== undefined && object.evmData !== null)
            ? exports.EvmTransactionData.fromPartial(object.evmData)
            : undefined;
        message.solanaData = (object.solanaData !== undefined && object.solanaData !== null)
            ? exports.SolanaTransactionData.fromPartial(object.solanaData)
            : undefined;
        message.suiData = (object.suiData !== undefined && object.suiData !== null)
            ? exports.SuiTransactionData.fromPartial(object.suiData)
            : undefined;
        return message;
    },
};
function createBaseSwapResponse() {
    return {
        uuid: "",
        amountOut: "",
        outputToken: undefined,
        pathSteps: [],
        amountIn: "",
        inputToken: "",
        refundAddress: "",
        chainId: "",
        recipientAddress: "",
        partnerId: 0,
        depositAddress: "",
        transactionData: undefined,
    };
}
exports.SwapResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.uuid !== "") {
            writer.uint32(10).string(message.uuid);
        }
        if (message.amountOut !== "") {
            writer.uint32(18).string(message.amountOut);
        }
        if (message.outputToken !== undefined) {
            exports.ChainToken.encode(message.outputToken, writer.uint32(26).fork()).join();
        }
        for (const v of message.pathSteps) {
            exports.Step.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.amountIn !== "") {
            writer.uint32(58).string(message.amountIn);
        }
        if (message.inputToken !== "") {
            writer.uint32(66).string(message.inputToken);
        }
        if (message.refundAddress !== "") {
            writer.uint32(74).string(message.refundAddress);
        }
        if (message.chainId !== "") {
            writer.uint32(82).string(message.chainId);
        }
        if (message.recipientAddress !== "") {
            writer.uint32(90).string(message.recipientAddress);
        }
        if (message.partnerId !== 0) {
            writer.uint32(96).uint32(message.partnerId);
        }
        if (message.depositAddress !== "") {
            writer.uint32(106).string(message.depositAddress);
        }
        if (message.transactionData !== undefined) {
            exports.TransactionData.encode(message.transactionData, writer.uint32(114).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwapResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.amountOut = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.outputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.pathSteps.push(exports.Step.decode(reader, reader.uint32()));
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.amountIn = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.inputToken = reader.string();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.refundAddress = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.chainId = reader.string();
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.recipientAddress = reader.string();
                    continue;
                }
                case 12: {
                    if (tag !== 96) {
                        break;
                    }
                    message.partnerId = reader.uint32();
                    continue;
                }
                case 13: {
                    if (tag !== 106) {
                        break;
                    }
                    message.depositAddress = reader.string();
                    continue;
                }
                case 14: {
                    if (tag !== 114) {
                        break;
                    }
                    message.transactionData = exports.TransactionData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
            amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
            outputToken: isSet(object.outputToken) ? exports.ChainToken.fromJSON(object.outputToken) : undefined,
            pathSteps: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.pathSteps) ? object.pathSteps.map((e) => exports.Step.fromJSON(e)) : [],
            amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
            inputToken: isSet(object.inputToken) ? globalThis.String(object.inputToken) : "",
            refundAddress: isSet(object.refundAddress) ? globalThis.String(object.refundAddress) : "",
            chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
            recipientAddress: isSet(object.recipientAddress) ? globalThis.String(object.recipientAddress) : "",
            partnerId: isSet(object.partnerId) ? globalThis.Number(object.partnerId) : 0,
            depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
            transactionData: isSet(object.transactionData) ? exports.TransactionData.fromJSON(object.transactionData) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.uuid !== "") {
            obj.uuid = message.uuid;
        }
        if (message.amountOut !== "") {
            obj.amountOut = message.amountOut;
        }
        if (message.outputToken !== undefined) {
            obj.outputToken = exports.ChainToken.toJSON(message.outputToken);
        }
        if ((_a = message.pathSteps) === null || _a === void 0 ? void 0 : _a.length) {
            obj.pathSteps = message.pathSteps.map((e) => exports.Step.toJSON(e));
        }
        if (message.amountIn !== "") {
            obj.amountIn = message.amountIn;
        }
        if (message.inputToken !== "") {
            obj.inputToken = message.inputToken;
        }
        if (message.refundAddress !== "") {
            obj.refundAddress = message.refundAddress;
        }
        if (message.chainId !== "") {
            obj.chainId = message.chainId;
        }
        if (message.recipientAddress !== "") {
            obj.recipientAddress = message.recipientAddress;
        }
        if (message.partnerId !== 0) {
            obj.partnerId = Math.round(message.partnerId);
        }
        if (message.depositAddress !== "") {
            obj.depositAddress = message.depositAddress;
        }
        if (message.transactionData !== undefined) {
            obj.transactionData = exports.TransactionData.toJSON(message.transactionData);
        }
        return obj;
    },
    create(base) {
        return exports.SwapResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseSwapResponse();
        message.uuid = (_a = object.uuid) !== null && _a !== void 0 ? _a : "";
        message.amountOut = (_b = object.amountOut) !== null && _b !== void 0 ? _b : "";
        message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
            ? exports.ChainToken.fromPartial(object.outputToken)
            : undefined;
        message.pathSteps = ((_c = object.pathSteps) === null || _c === void 0 ? void 0 : _c.map((e) => exports.Step.fromPartial(e))) || [];
        message.amountIn = (_d = object.amountIn) !== null && _d !== void 0 ? _d : "";
        message.inputToken = (_e = object.inputToken) !== null && _e !== void 0 ? _e : "";
        message.refundAddress = (_f = object.refundAddress) !== null && _f !== void 0 ? _f : "";
        message.chainId = (_g = object.chainId) !== null && _g !== void 0 ? _g : "";
        message.recipientAddress = (_h = object.recipientAddress) !== null && _h !== void 0 ? _h : "";
        message.partnerId = (_j = object.partnerId) !== null && _j !== void 0 ? _j : 0;
        message.depositAddress = (_k = object.depositAddress) !== null && _k !== void 0 ? _k : "";
        message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
            ? exports.TransactionData.fromPartial(object.transactionData)
            : undefined;
        return message;
    },
};
function createBaseEvmTransactionData() {
    return { contractAddress: "", calldata: "", value: "" };
}
exports.EvmTransactionData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.contractAddress !== "") {
            writer.uint32(10).string(message.contractAddress);
        }
        if (message.calldata !== "") {
            writer.uint32(18).string(message.calldata);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvmTransactionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.contractAddress = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.calldata = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
            calldata: isSet(object.calldata) ? globalThis.String(object.calldata) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.contractAddress !== "") {
            obj.contractAddress = message.contractAddress;
        }
        if (message.calldata !== "") {
            obj.calldata = message.calldata;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.EvmTransactionData.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseEvmTransactionData();
        message.contractAddress = (_a = object.contractAddress) !== null && _a !== void 0 ? _a : "";
        message.calldata = (_b = object.calldata) !== null && _b !== void 0 ? _b : "";
        message.value = (_c = object.value) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseSolanaTransactionData() {
    return { txMessages: [], blockhash: "", lastValidBlockHeight: 0 };
}
exports.SolanaTransactionData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.txMessages) {
            writer.uint32(10).string(v);
        }
        if (message.blockhash !== "") {
            writer.uint32(18).string(message.blockhash);
        }
        if (message.lastValidBlockHeight !== 0) {
            writer.uint32(24).uint64(message.lastValidBlockHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSolanaTransactionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.txMessages.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.blockhash = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.lastValidBlockHeight = longToNumber(reader.uint64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            txMessages: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.txMessages)
                ? object.txMessages.map((e) => globalThis.String(e))
                : [],
            blockhash: isSet(object.blockhash) ? globalThis.String(object.blockhash) : "",
            lastValidBlockHeight: isSet(object.lastValidBlockHeight) ? globalThis.Number(object.lastValidBlockHeight) : 0,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.txMessages) === null || _a === void 0 ? void 0 : _a.length) {
            obj.txMessages = message.txMessages;
        }
        if (message.blockhash !== "") {
            obj.blockhash = message.blockhash;
        }
        if (message.lastValidBlockHeight !== 0) {
            obj.lastValidBlockHeight = Math.round(message.lastValidBlockHeight);
        }
        return obj;
    },
    create(base) {
        return exports.SolanaTransactionData.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSolanaTransactionData();
        message.txMessages = ((_a = object.txMessages) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.blockhash = (_b = object.blockhash) !== null && _b !== void 0 ? _b : "";
        message.lastValidBlockHeight = (_c = object.lastValidBlockHeight) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseSuiTransactionData() {
    return { from: "", to: "", data: "", value: "" };
}
exports.SuiTransactionData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.from !== "") {
            writer.uint32(10).string(message.from);
        }
        if (message.to !== "") {
            writer.uint32(18).string(message.to);
        }
        if (message.data !== "") {
            writer.uint32(26).string(message.data);
        }
        if (message.value !== "") {
            writer.uint32(34).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSuiTransactionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.from = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.to = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            from: isSet(object.from) ? globalThis.String(object.from) : "",
            to: isSet(object.to) ? globalThis.String(object.to) : "",
            data: isSet(object.data) ? globalThis.String(object.data) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.from !== "") {
            obj.from = message.from;
        }
        if (message.to !== "") {
            obj.to = message.to;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.SuiTransactionData.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSuiTransactionData();
        message.from = (_a = object.from) !== null && _a !== void 0 ? _a : "";
        message.to = (_b = object.to) !== null && _b !== void 0 ? _b : "";
        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : "";
        message.value = (_d = object.value) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseXploreRequest() {
    return {
        inputToken: undefined,
        outputToken: undefined,
        amountIn: "",
        amountOutMin: "",
        slippageTolerancePercent: 0,
        recipientAddress: "",
        senderAddress: "",
        exactOut: false,
        timeoutMs: 0,
        generateDepositAddress: false,
    };
}
exports.XploreRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.inputToken !== undefined) {
            exports.ChainToken.encode(message.inputToken, writer.uint32(10).fork()).join();
        }
        if (message.outputToken !== undefined) {
            exports.ChainToken.encode(message.outputToken, writer.uint32(18).fork()).join();
        }
        if (message.amountIn !== "") {
            writer.uint32(26).string(message.amountIn);
        }
        if (message.amountOutMin !== "") {
            writer.uint32(34).string(message.amountOutMin);
        }
        if (message.slippageTolerancePercent !== 0) {
            writer.uint32(40).uint64(message.slippageTolerancePercent);
        }
        if (message.recipientAddress !== "") {
            writer.uint32(50).string(message.recipientAddress);
        }
        if (message.senderAddress !== "") {
            writer.uint32(58).string(message.senderAddress);
        }
        if (message.exactOut !== false) {
            writer.uint32(64).bool(message.exactOut);
        }
        if (message.timeoutMs !== 0) {
            writer.uint32(72).int64(message.timeoutMs);
        }
        if (message.generateDepositAddress !== false) {
            writer.uint32(80).bool(message.generateDepositAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseXploreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.inputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.outputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.amountIn = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.amountOutMin = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.slippageTolerancePercent = longToNumber(reader.uint64());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.recipientAddress = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.senderAddress = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.exactOut = reader.bool();
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.timeoutMs = longToNumber(reader.int64());
                    continue;
                }
                case 10: {
                    if (tag !== 80) {
                        break;
                    }
                    message.generateDepositAddress = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            inputToken: isSet(object.inputToken) ? exports.ChainToken.fromJSON(object.inputToken) : undefined,
            outputToken: isSet(object.outputToken) ? exports.ChainToken.fromJSON(object.outputToken) : undefined,
            amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
            amountOutMin: isSet(object.amountOutMin) ? globalThis.String(object.amountOutMin) : "",
            slippageTolerancePercent: isSet(object.slippageTolerancePercent)
                ? globalThis.Number(object.slippageTolerancePercent)
                : 0,
            recipientAddress: isSet(object.recipientAddress) ? globalThis.String(object.recipientAddress) : "",
            senderAddress: isSet(object.senderAddress) ? globalThis.String(object.senderAddress) : "",
            exactOut: isSet(object.exactOut) ? globalThis.Boolean(object.exactOut) : false,
            timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
            generateDepositAddress: isSet(object.generateDepositAddress)
                ? globalThis.Boolean(object.generateDepositAddress)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.inputToken !== undefined) {
            obj.inputToken = exports.ChainToken.toJSON(message.inputToken);
        }
        if (message.outputToken !== undefined) {
            obj.outputToken = exports.ChainToken.toJSON(message.outputToken);
        }
        if (message.amountIn !== "") {
            obj.amountIn = message.amountIn;
        }
        if (message.amountOutMin !== "") {
            obj.amountOutMin = message.amountOutMin;
        }
        if (message.slippageTolerancePercent !== 0) {
            obj.slippageTolerancePercent = Math.round(message.slippageTolerancePercent);
        }
        if (message.recipientAddress !== "") {
            obj.recipientAddress = message.recipientAddress;
        }
        if (message.senderAddress !== "") {
            obj.senderAddress = message.senderAddress;
        }
        if (message.exactOut !== false) {
            obj.exactOut = message.exactOut;
        }
        if (message.timeoutMs !== 0) {
            obj.timeoutMs = Math.round(message.timeoutMs);
        }
        if (message.generateDepositAddress !== false) {
            obj.generateDepositAddress = message.generateDepositAddress;
        }
        return obj;
    },
    create(base) {
        return exports.XploreRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseXploreRequest();
        message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
            ? exports.ChainToken.fromPartial(object.inputToken)
            : undefined;
        message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
            ? exports.ChainToken.fromPartial(object.outputToken)
            : undefined;
        message.amountIn = (_a = object.amountIn) !== null && _a !== void 0 ? _a : "";
        message.amountOutMin = (_b = object.amountOutMin) !== null && _b !== void 0 ? _b : "";
        message.slippageTolerancePercent = (_c = object.slippageTolerancePercent) !== null && _c !== void 0 ? _c : 0;
        message.recipientAddress = (_d = object.recipientAddress) !== null && _d !== void 0 ? _d : "";
        message.senderAddress = (_e = object.senderAddress) !== null && _e !== void 0 ? _e : "";
        message.exactOut = (_f = object.exactOut) !== null && _f !== void 0 ? _f : false;
        message.timeoutMs = (_g = object.timeoutMs) !== null && _g !== void 0 ? _g : 0;
        message.generateDepositAddress = (_h = object.generateDepositAddress) !== null && _h !== void 0 ? _h : false;
        return message;
    },
};
function createBaseAPISwapResponse() {
    return {
        uuid: "",
        amountIn: "",
        amountOut: "",
        outputToken: undefined,
        pathSteps: [],
        depositAddress: "",
        transactionData: undefined,
    };
}
exports.APISwapResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.uuid !== "") {
            writer.uint32(10).string(message.uuid);
        }
        if (message.amountIn !== "") {
            writer.uint32(18).string(message.amountIn);
        }
        if (message.amountOut !== "") {
            writer.uint32(26).string(message.amountOut);
        }
        if (message.outputToken !== undefined) {
            exports.ChainToken.encode(message.outputToken, writer.uint32(34).fork()).join();
        }
        for (const v of message.pathSteps) {
            exports.Step.encode(v, writer.uint32(42).fork()).join();
        }
        if (message.depositAddress !== "") {
            writer.uint32(50).string(message.depositAddress);
        }
        if (message.transactionData !== undefined) {
            exports.TransactionData.encode(message.transactionData, writer.uint32(58).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAPISwapResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.amountIn = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.amountOut = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.outputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.pathSteps.push(exports.Step.decode(reader, reader.uint32()));
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.depositAddress = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.transactionData = exports.TransactionData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
            amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
            amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
            outputToken: isSet(object.outputToken) ? exports.ChainToken.fromJSON(object.outputToken) : undefined,
            pathSteps: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.pathSteps) ? object.pathSteps.map((e) => exports.Step.fromJSON(e)) : [],
            depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
            transactionData: isSet(object.transactionData) ? exports.TransactionData.fromJSON(object.transactionData) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.uuid !== "") {
            obj.uuid = message.uuid;
        }
        if (message.amountIn !== "") {
            obj.amountIn = message.amountIn;
        }
        if (message.amountOut !== "") {
            obj.amountOut = message.amountOut;
        }
        if (message.outputToken !== undefined) {
            obj.outputToken = exports.ChainToken.toJSON(message.outputToken);
        }
        if ((_a = message.pathSteps) === null || _a === void 0 ? void 0 : _a.length) {
            obj.pathSteps = message.pathSteps.map((e) => exports.Step.toJSON(e));
        }
        if (message.depositAddress !== "") {
            obj.depositAddress = message.depositAddress;
        }
        if (message.transactionData !== undefined) {
            obj.transactionData = exports.TransactionData.toJSON(message.transactionData);
        }
        return obj;
    },
    create(base) {
        return exports.APISwapResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseAPISwapResponse();
        message.uuid = (_a = object.uuid) !== null && _a !== void 0 ? _a : "";
        message.amountIn = (_b = object.amountIn) !== null && _b !== void 0 ? _b : "";
        message.amountOut = (_c = object.amountOut) !== null && _c !== void 0 ? _c : "";
        message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
            ? exports.ChainToken.fromPartial(object.outputToken)
            : undefined;
        message.pathSteps = ((_d = object.pathSteps) === null || _d === void 0 ? void 0 : _d.map((e) => exports.Step.fromPartial(e))) || [];
        message.depositAddress = (_e = object.depositAddress) !== null && _e !== void 0 ? _e : "";
        message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
            ? exports.TransactionData.fromPartial(object.transactionData)
            : undefined;
        return message;
    },
};
function createBaseStep() {
    return { inputToken: undefined, amountIn: "", protocolName: "", outputToken: undefined, amountOut: "" };
}
exports.Step = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.inputToken !== undefined) {
            exports.ChainToken.encode(message.inputToken, writer.uint32(10).fork()).join();
        }
        if (message.amountIn !== "") {
            writer.uint32(18).string(message.amountIn);
        }
        if (message.protocolName !== "") {
            writer.uint32(26).string(message.protocolName);
        }
        if (message.outputToken !== undefined) {
            exports.ChainToken.encode(message.outputToken, writer.uint32(34).fork()).join();
        }
        if (message.amountOut !== "") {
            writer.uint32(42).string(message.amountOut);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStep();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.inputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.amountIn = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.protocolName = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.outputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.amountOut = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            inputToken: isSet(object.inputToken) ? exports.ChainToken.fromJSON(object.inputToken) : undefined,
            amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
            protocolName: isSet(object.protocolName) ? globalThis.String(object.protocolName) : "",
            outputToken: isSet(object.outputToken) ? exports.ChainToken.fromJSON(object.outputToken) : undefined,
            amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.inputToken !== undefined) {
            obj.inputToken = exports.ChainToken.toJSON(message.inputToken);
        }
        if (message.amountIn !== "") {
            obj.amountIn = message.amountIn;
        }
        if (message.protocolName !== "") {
            obj.protocolName = message.protocolName;
        }
        if (message.outputToken !== undefined) {
            obj.outputToken = exports.ChainToken.toJSON(message.outputToken);
        }
        if (message.amountOut !== "") {
            obj.amountOut = message.amountOut;
        }
        return obj;
    },
    create(base) {
        return exports.Step.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseStep();
        message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
            ? exports.ChainToken.fromPartial(object.inputToken)
            : undefined;
        message.amountIn = (_a = object.amountIn) !== null && _a !== void 0 ? _a : "";
        message.protocolName = (_b = object.protocolName) !== null && _b !== void 0 ? _b : "";
        message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
            ? exports.ChainToken.fromPartial(object.outputToken)
            : undefined;
        message.amountOut = (_c = object.amountOut) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseRouteStep() {
    return {
        nodeId: "",
        inputToken: undefined,
        outputToken: undefined,
        amountIn: "",
        amountOut: "",
        transactionData: undefined,
    };
}
exports.RouteStep = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.inputToken !== undefined) {
            exports.ChainToken.encode(message.inputToken, writer.uint32(18).fork()).join();
        }
        if (message.outputToken !== undefined) {
            exports.ChainToken.encode(message.outputToken, writer.uint32(26).fork()).join();
        }
        if (message.amountIn !== "") {
            writer.uint32(34).string(message.amountIn);
        }
        if (message.amountOut !== "") {
            writer.uint32(42).string(message.amountOut);
        }
        if (message.transactionData !== undefined) {
            exports.TransactionData.encode(message.transactionData, writer.uint32(50).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRouteStep();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.inputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.outputToken = exports.ChainToken.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.amountIn = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.amountOut = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.transactionData = exports.TransactionData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            inputToken: isSet(object.inputToken) ? exports.ChainToken.fromJSON(object.inputToken) : undefined,
            outputToken: isSet(object.outputToken) ? exports.ChainToken.fromJSON(object.outputToken) : undefined,
            amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
            amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
            transactionData: isSet(object.transactionData) ? exports.TransactionData.fromJSON(object.transactionData) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.inputToken !== undefined) {
            obj.inputToken = exports.ChainToken.toJSON(message.inputToken);
        }
        if (message.outputToken !== undefined) {
            obj.outputToken = exports.ChainToken.toJSON(message.outputToken);
        }
        if (message.amountIn !== "") {
            obj.amountIn = message.amountIn;
        }
        if (message.amountOut !== "") {
            obj.amountOut = message.amountOut;
        }
        if (message.transactionData !== undefined) {
            obj.transactionData = exports.TransactionData.toJSON(message.transactionData);
        }
        return obj;
    },
    create(base) {
        return exports.RouteStep.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseRouteStep();
        message.nodeId = (_a = object.nodeId) !== null && _a !== void 0 ? _a : "";
        message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
            ? exports.ChainToken.fromPartial(object.inputToken)
            : undefined;
        message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
            ? exports.ChainToken.fromPartial(object.outputToken)
            : undefined;
        message.amountIn = (_b = object.amountIn) !== null && _b !== void 0 ? _b : "";
        message.amountOut = (_c = object.amountOut) !== null && _c !== void 0 ? _c : "";
        message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
            ? exports.TransactionData.fromPartial(object.transactionData)
            : undefined;
        return message;
    },
};
function createBaseXploreResponse() {
    return {
        amountIn: "",
        amountOut: "",
        priceImpact: 0,
        route: [],
        executionTime: 0,
        gasEstimate: 0,
        depositAddress: "",
        value: "",
        transactionData: undefined,
    };
}
exports.XploreResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.amountIn !== "") {
            writer.uint32(10).string(message.amountIn);
        }
        if (message.amountOut !== "") {
            writer.uint32(18).string(message.amountOut);
        }
        if (message.priceImpact !== 0) {
            writer.uint32(25).double(message.priceImpact);
        }
        for (const v of message.route) {
            exports.RouteStep.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.executionTime !== 0) {
            writer.uint32(41).double(message.executionTime);
        }
        if (message.gasEstimate !== 0) {
            writer.uint32(48).int64(message.gasEstimate);
        }
        if (message.depositAddress !== "") {
            writer.uint32(58).string(message.depositAddress);
        }
        if (message.value !== "") {
            writer.uint32(66).string(message.value);
        }
        if (message.transactionData !== undefined) {
            exports.TransactionData.encode(message.transactionData, writer.uint32(74).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseXploreResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.amountIn = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.amountOut = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 25) {
                        break;
                    }
                    message.priceImpact = reader.double();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.route.push(exports.RouteStep.decode(reader, reader.uint32()));
                    continue;
                }
                case 5: {
                    if (tag !== 41) {
                        break;
                    }
                    message.executionTime = reader.double();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.gasEstimate = longToNumber(reader.int64());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.depositAddress = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.transactionData = exports.TransactionData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
            amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
            priceImpact: isSet(object.priceImpact) ? globalThis.Number(object.priceImpact) : 0,
            route: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.route) ? object.route.map((e) => exports.RouteStep.fromJSON(e)) : [],
            executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : 0,
            gasEstimate: isSet(object.gasEstimate) ? globalThis.Number(object.gasEstimate) : 0,
            depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
            transactionData: isSet(object.transactionData) ? exports.TransactionData.fromJSON(object.transactionData) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.amountIn !== "") {
            obj.amountIn = message.amountIn;
        }
        if (message.amountOut !== "") {
            obj.amountOut = message.amountOut;
        }
        if (message.priceImpact !== 0) {
            obj.priceImpact = message.priceImpact;
        }
        if ((_a = message.route) === null || _a === void 0 ? void 0 : _a.length) {
            obj.route = message.route.map((e) => exports.RouteStep.toJSON(e));
        }
        if (message.executionTime !== 0) {
            obj.executionTime = message.executionTime;
        }
        if (message.gasEstimate !== 0) {
            obj.gasEstimate = Math.round(message.gasEstimate);
        }
        if (message.depositAddress !== "") {
            obj.depositAddress = message.depositAddress;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.transactionData !== undefined) {
            obj.transactionData = exports.TransactionData.toJSON(message.transactionData);
        }
        return obj;
    },
    create(base) {
        return exports.XploreResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseXploreResponse();
        message.amountIn = (_a = object.amountIn) !== null && _a !== void 0 ? _a : "";
        message.amountOut = (_b = object.amountOut) !== null && _b !== void 0 ? _b : "";
        message.priceImpact = (_c = object.priceImpact) !== null && _c !== void 0 ? _c : 0;
        message.route = ((_d = object.route) === null || _d === void 0 ? void 0 : _d.map((e) => exports.RouteStep.fromPartial(e))) || [];
        message.executionTime = (_e = object.executionTime) !== null && _e !== void 0 ? _e : 0;
        message.gasEstimate = (_f = object.gasEstimate) !== null && _f !== void 0 ? _f : 0;
        message.depositAddress = (_g = object.depositAddress) !== null && _g !== void 0 ? _g : "";
        message.value = (_h = object.value) !== null && _h !== void 0 ? _h : "";
        message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
            ? exports.TransactionData.fromPartial(object.transactionData)
            : undefined;
        return message;
    },
};
exports.AggregatorService = {
    aggregateCall: {
        path: "/xplore.Aggregator/AggregateCall",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.XploreRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.XploreRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.XploreResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.XploreResponse.decode(value),
    },
    getTransactionRecord: {
        path: "/xplore.Aggregator/GetTransactionRecord",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.TransactionRecordRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.TransactionRecordRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.TransactionRecord.encode(value).finish()),
        responseDeserialize: (value) => exports.TransactionRecord.decode(value),
    },
};
exports.AggregatorClient = (0, grpc_js_1.makeGenericClientConstructor)(exports.AggregatorService, "xplore.Aggregator");
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
