// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: aggregator.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "xplore";

/** Status of the transaction */
export enum TransactionStatus {
  UNKNOWN = 0,
  PENDING = 1,
  COMPLETED = 2,
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function transactionStatusFromJSON(object: any): TransactionStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return TransactionStatus.UNKNOWN;
    case 1:
    case "PENDING":
      return TransactionStatus.PENDING;
    case 2:
    case "COMPLETED":
      return TransactionStatus.COMPLETED;
    case 3:
    case "FAILED":
      return TransactionStatus.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionStatus.UNRECOGNIZED;
  }
}

export function transactionStatusToJSON(object: TransactionStatus): string {
  switch (object) {
    case TransactionStatus.UNKNOWN:
      return "UNKNOWN";
    case TransactionStatus.PENDING:
      return "PENDING";
    case TransactionStatus.COMPLETED:
      return "COMPLETED";
    case TransactionStatus.FAILED:
      return "FAILED";
    case TransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ChainToken {
  chainId: string;
  address: string;
  isNative?: boolean | undefined;
}

export interface TransactionRecordRequest {
  transactionHash: string;
}

/** Transaction record for cross-chain operations */
export interface TransactionRecord {
  sourceTransactionHash: string;
  destinationTransactionHash: string;
  sourceTimestamp: number;
  destinationTimestamp: number;
  node: string;
  sender: string;
  amountIn: string;
  inputToken: ChainToken | undefined;
  outputToken: ChainToken | undefined;
  amountOut: string;
  recipientAddress: string;
  status: TransactionStatus;
}

export interface SwapRequest {
  inputToken: ChainToken | undefined;
  outputToken: ChainToken | undefined;
  amountIn: string;
  amountOutMin: string;
  slippageTolerancePercent: number;
  recipientAddress: string;
  senderAddress: string;
  exactOut: boolean;
  timeoutMs: number;
  generateDepositAddress: boolean;
}

/** Define a common transaction data message */
export interface TransactionData {
  evmData?: EvmTransactionData | undefined;
  solanaData?: SolanaTransactionData | undefined;
  suiData?: SuiTransactionData | undefined;
}

/** Update SwapResponse to use the common type */
export interface SwapResponse {
  uuid: string;
  amountOut: string;
  outputToken: ChainToken | undefined;
  pathSteps: Step[];
  amountIn: string;
  inputToken: string;
  refundAddress: string;
  chainId: string;
  recipientAddress: string;
  partnerId: number;
  depositAddress: string;
  /** Use the common wrapper */
  transactionData: TransactionData | undefined;
}

/** EVM transaction data */
export interface EvmTransactionData {
  /** Moved from SwapResponse */
  contractAddress: string;
  /** Moved from SwapResponse */
  calldata: string;
  /** Optional value field for ETH transfers */
  value: string;
}

/** Solana transaction data */
export interface SolanaTransactionData {
  txMessages: string[];
  blockhash: string;
  lastValidBlockHeight: number;
}

/** Sui transaction data (placeholder for future implementation) */
export interface SuiTransactionData {
  from: string;
  to: string;
  data: string;
  value: string;
}

export interface XploreRequest {
  inputToken: ChainToken | undefined;
  outputToken: ChainToken | undefined;
  amountIn: string;
  amountOutMin: string;
  slippageTolerancePercent: number;
  recipientAddress: string;
  senderAddress: string;
  exactOut: boolean;
  timeoutMs: number;
  generateDepositAddress: boolean;
}

export interface APISwapResponse {
  uuid: string;
  amountIn: string;
  amountOut: string;
  outputToken: ChainToken | undefined;
  pathSteps: Step[];
  depositAddress: string;
  transactionData: TransactionData | undefined;
}

export interface Step {
  inputToken: ChainToken | undefined;
  amountIn: string;
  protocolName: string;
  outputToken: ChainToken | undefined;
  amountOut: string;
}

/** Update RouteStep to use the common type */
export interface RouteStep {
  nodeId: string;
  inputToken: ChainToken | undefined;
  outputToken: ChainToken | undefined;
  amountIn: string;
  amountOut: string;
  /** Use the common wrapper */
  transactionData: TransactionData | undefined;
}

export interface XploreResponse {
  amountIn: string;
  amountOut: string;
  priceImpact: number;
  route: RouteStep[];
  executionTime: number;
  gasEstimate: number;
  depositAddress: string;
  value: string;
  transactionData: TransactionData | undefined;
}

function createBaseChainToken(): ChainToken {
  return { chainId: "", address: "", isNative: undefined };
}

export const ChainToken: MessageFns<ChainToken> = {
  encode(message: ChainToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.isNative !== undefined) {
      writer.uint32(24).bool(message.isNative);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isNative = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainToken {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : undefined,
    };
  },

  toJSON(message: ChainToken): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.isNative !== undefined) {
      obj.isNative = message.isNative;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainToken>, I>>(base?: I): ChainToken {
    return ChainToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainToken>, I>>(object: I): ChainToken {
    const message = createBaseChainToken();
    message.chainId = object.chainId ?? "";
    message.address = object.address ?? "";
    message.isNative = object.isNative ?? undefined;
    return message;
  },
};

function createBaseTransactionRecordRequest(): TransactionRecordRequest {
  return { transactionHash: "" };
}

export const TransactionRecordRequest: MessageFns<TransactionRecordRequest> = {
  encode(message: TransactionRecordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionHash !== "") {
      writer.uint32(10).string(message.transactionHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionRecordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionRecordRequest {
    return { transactionHash: isSet(object.transactionHash) ? globalThis.String(object.transactionHash) : "" };
  },

  toJSON(message: TransactionRecordRequest): unknown {
    const obj: any = {};
    if (message.transactionHash !== "") {
      obj.transactionHash = message.transactionHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionRecordRequest>, I>>(base?: I): TransactionRecordRequest {
    return TransactionRecordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionRecordRequest>, I>>(object: I): TransactionRecordRequest {
    const message = createBaseTransactionRecordRequest();
    message.transactionHash = object.transactionHash ?? "";
    return message;
  },
};

function createBaseTransactionRecord(): TransactionRecord {
  return {
    sourceTransactionHash: "",
    destinationTransactionHash: "",
    sourceTimestamp: 0,
    destinationTimestamp: 0,
    node: "",
    sender: "",
    amountIn: "",
    inputToken: undefined,
    outputToken: undefined,
    amountOut: "",
    recipientAddress: "",
    status: 0,
  };
}

export const TransactionRecord: MessageFns<TransactionRecord> = {
  encode(message: TransactionRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceTransactionHash !== "") {
      writer.uint32(10).string(message.sourceTransactionHash);
    }
    if (message.destinationTransactionHash !== "") {
      writer.uint32(18).string(message.destinationTransactionHash);
    }
    if (message.sourceTimestamp !== 0) {
      writer.uint32(24).uint64(message.sourceTimestamp);
    }
    if (message.destinationTimestamp !== 0) {
      writer.uint32(32).uint64(message.destinationTimestamp);
    }
    if (message.node !== "") {
      writer.uint32(42).string(message.node);
    }
    if (message.sender !== "") {
      writer.uint32(50).string(message.sender);
    }
    if (message.amountIn !== "") {
      writer.uint32(58).string(message.amountIn);
    }
    if (message.inputToken !== undefined) {
      ChainToken.encode(message.inputToken, writer.uint32(66).fork()).join();
    }
    if (message.outputToken !== undefined) {
      ChainToken.encode(message.outputToken, writer.uint32(74).fork()).join();
    }
    if (message.amountOut !== "") {
      writer.uint32(82).string(message.amountOut);
    }
    if (message.recipientAddress !== "") {
      writer.uint32(90).string(message.recipientAddress);
    }
    if (message.status !== 0) {
      writer.uint32(96).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceTransactionHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destinationTransactionHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sourceTimestamp = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.destinationTimestamp = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.node = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.outputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.recipientAddress = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionRecord {
    return {
      sourceTransactionHash: isSet(object.sourceTransactionHash) ? globalThis.String(object.sourceTransactionHash) : "",
      destinationTransactionHash: isSet(object.destinationTransactionHash)
        ? globalThis.String(object.destinationTransactionHash)
        : "",
      sourceTimestamp: isSet(object.sourceTimestamp) ? globalThis.Number(object.sourceTimestamp) : 0,
      destinationTimestamp: isSet(object.destinationTimestamp) ? globalThis.Number(object.destinationTimestamp) : 0,
      node: isSet(object.node) ? globalThis.String(object.node) : "",
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      inputToken: isSet(object.inputToken) ? ChainToken.fromJSON(object.inputToken) : undefined,
      outputToken: isSet(object.outputToken) ? ChainToken.fromJSON(object.outputToken) : undefined,
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
      recipientAddress: isSet(object.recipientAddress) ? globalThis.String(object.recipientAddress) : "",
      status: isSet(object.status) ? transactionStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: TransactionRecord): unknown {
    const obj: any = {};
    if (message.sourceTransactionHash !== "") {
      obj.sourceTransactionHash = message.sourceTransactionHash;
    }
    if (message.destinationTransactionHash !== "") {
      obj.destinationTransactionHash = message.destinationTransactionHash;
    }
    if (message.sourceTimestamp !== 0) {
      obj.sourceTimestamp = Math.round(message.sourceTimestamp);
    }
    if (message.destinationTimestamp !== 0) {
      obj.destinationTimestamp = Math.round(message.destinationTimestamp);
    }
    if (message.node !== "") {
      obj.node = message.node;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.inputToken !== undefined) {
      obj.inputToken = ChainToken.toJSON(message.inputToken);
    }
    if (message.outputToken !== undefined) {
      obj.outputToken = ChainToken.toJSON(message.outputToken);
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    if (message.recipientAddress !== "") {
      obj.recipientAddress = message.recipientAddress;
    }
    if (message.status !== 0) {
      obj.status = transactionStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionRecord>, I>>(base?: I): TransactionRecord {
    return TransactionRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionRecord>, I>>(object: I): TransactionRecord {
    const message = createBaseTransactionRecord();
    message.sourceTransactionHash = object.sourceTransactionHash ?? "";
    message.destinationTransactionHash = object.destinationTransactionHash ?? "";
    message.sourceTimestamp = object.sourceTimestamp ?? 0;
    message.destinationTimestamp = object.destinationTimestamp ?? 0;
    message.node = object.node ?? "";
    message.sender = object.sender ?? "";
    message.amountIn = object.amountIn ?? "";
    message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
      ? ChainToken.fromPartial(object.inputToken)
      : undefined;
    message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
      ? ChainToken.fromPartial(object.outputToken)
      : undefined;
    message.amountOut = object.amountOut ?? "";
    message.recipientAddress = object.recipientAddress ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseSwapRequest(): SwapRequest {
  return {
    inputToken: undefined,
    outputToken: undefined,
    amountIn: "",
    amountOutMin: "",
    slippageTolerancePercent: 0,
    recipientAddress: "",
    senderAddress: "",
    exactOut: false,
    timeoutMs: 0,
    generateDepositAddress: false,
  };
}

export const SwapRequest: MessageFns<SwapRequest> = {
  encode(message: SwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputToken !== undefined) {
      ChainToken.encode(message.inputToken, writer.uint32(10).fork()).join();
    }
    if (message.outputToken !== undefined) {
      ChainToken.encode(message.outputToken, writer.uint32(18).fork()).join();
    }
    if (message.amountIn !== "") {
      writer.uint32(26).string(message.amountIn);
    }
    if (message.amountOutMin !== "") {
      writer.uint32(34).string(message.amountOutMin);
    }
    if (message.slippageTolerancePercent !== 0) {
      writer.uint32(40).uint64(message.slippageTolerancePercent);
    }
    if (message.recipientAddress !== "") {
      writer.uint32(50).string(message.recipientAddress);
    }
    if (message.senderAddress !== "") {
      writer.uint32(58).string(message.senderAddress);
    }
    if (message.exactOut !== false) {
      writer.uint32(64).bool(message.exactOut);
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(72).int64(message.timeoutMs);
    }
    if (message.generateDepositAddress !== false) {
      writer.uint32(80).bool(message.generateDepositAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amountOutMin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.slippageTolerancePercent = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.recipientAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.senderAddress = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.exactOut = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.timeoutMs = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.generateDepositAddress = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapRequest {
    return {
      inputToken: isSet(object.inputToken) ? ChainToken.fromJSON(object.inputToken) : undefined,
      outputToken: isSet(object.outputToken) ? ChainToken.fromJSON(object.outputToken) : undefined,
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      amountOutMin: isSet(object.amountOutMin) ? globalThis.String(object.amountOutMin) : "",
      slippageTolerancePercent: isSet(object.slippageTolerancePercent)
        ? globalThis.Number(object.slippageTolerancePercent)
        : 0,
      recipientAddress: isSet(object.recipientAddress) ? globalThis.String(object.recipientAddress) : "",
      senderAddress: isSet(object.senderAddress) ? globalThis.String(object.senderAddress) : "",
      exactOut: isSet(object.exactOut) ? globalThis.Boolean(object.exactOut) : false,
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
      generateDepositAddress: isSet(object.generateDepositAddress)
        ? globalThis.Boolean(object.generateDepositAddress)
        : false,
    };
  },

  toJSON(message: SwapRequest): unknown {
    const obj: any = {};
    if (message.inputToken !== undefined) {
      obj.inputToken = ChainToken.toJSON(message.inputToken);
    }
    if (message.outputToken !== undefined) {
      obj.outputToken = ChainToken.toJSON(message.outputToken);
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.amountOutMin !== "") {
      obj.amountOutMin = message.amountOutMin;
    }
    if (message.slippageTolerancePercent !== 0) {
      obj.slippageTolerancePercent = Math.round(message.slippageTolerancePercent);
    }
    if (message.recipientAddress !== "") {
      obj.recipientAddress = message.recipientAddress;
    }
    if (message.senderAddress !== "") {
      obj.senderAddress = message.senderAddress;
    }
    if (message.exactOut !== false) {
      obj.exactOut = message.exactOut;
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    if (message.generateDepositAddress !== false) {
      obj.generateDepositAddress = message.generateDepositAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapRequest>, I>>(base?: I): SwapRequest {
    return SwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapRequest>, I>>(object: I): SwapRequest {
    const message = createBaseSwapRequest();
    message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
      ? ChainToken.fromPartial(object.inputToken)
      : undefined;
    message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
      ? ChainToken.fromPartial(object.outputToken)
      : undefined;
    message.amountIn = object.amountIn ?? "";
    message.amountOutMin = object.amountOutMin ?? "";
    message.slippageTolerancePercent = object.slippageTolerancePercent ?? 0;
    message.recipientAddress = object.recipientAddress ?? "";
    message.senderAddress = object.senderAddress ?? "";
    message.exactOut = object.exactOut ?? false;
    message.timeoutMs = object.timeoutMs ?? 0;
    message.generateDepositAddress = object.generateDepositAddress ?? false;
    return message;
  },
};

function createBaseTransactionData(): TransactionData {
  return { evmData: undefined, solanaData: undefined, suiData: undefined };
}

export const TransactionData: MessageFns<TransactionData> = {
  encode(message: TransactionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evmData !== undefined) {
      EvmTransactionData.encode(message.evmData, writer.uint32(10).fork()).join();
    }
    if (message.solanaData !== undefined) {
      SolanaTransactionData.encode(message.solanaData, writer.uint32(18).fork()).join();
    }
    if (message.suiData !== undefined) {
      SuiTransactionData.encode(message.suiData, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evmData = EvmTransactionData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.solanaData = SolanaTransactionData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.suiData = SuiTransactionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData {
    return {
      evmData: isSet(object.evmData) ? EvmTransactionData.fromJSON(object.evmData) : undefined,
      solanaData: isSet(object.solanaData) ? SolanaTransactionData.fromJSON(object.solanaData) : undefined,
      suiData: isSet(object.suiData) ? SuiTransactionData.fromJSON(object.suiData) : undefined,
    };
  },

  toJSON(message: TransactionData): unknown {
    const obj: any = {};
    if (message.evmData !== undefined) {
      obj.evmData = EvmTransactionData.toJSON(message.evmData);
    }
    if (message.solanaData !== undefined) {
      obj.solanaData = SolanaTransactionData.toJSON(message.solanaData);
    }
    if (message.suiData !== undefined) {
      obj.suiData = SuiTransactionData.toJSON(message.suiData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionData>, I>>(base?: I): TransactionData {
    return TransactionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionData>, I>>(object: I): TransactionData {
    const message = createBaseTransactionData();
    message.evmData = (object.evmData !== undefined && object.evmData !== null)
      ? EvmTransactionData.fromPartial(object.evmData)
      : undefined;
    message.solanaData = (object.solanaData !== undefined && object.solanaData !== null)
      ? SolanaTransactionData.fromPartial(object.solanaData)
      : undefined;
    message.suiData = (object.suiData !== undefined && object.suiData !== null)
      ? SuiTransactionData.fromPartial(object.suiData)
      : undefined;
    return message;
  },
};

function createBaseSwapResponse(): SwapResponse {
  return {
    uuid: "",
    amountOut: "",
    outputToken: undefined,
    pathSteps: [],
    amountIn: "",
    inputToken: "",
    refundAddress: "",
    chainId: "",
    recipientAddress: "",
    partnerId: 0,
    depositAddress: "",
    transactionData: undefined,
  };
}

export const SwapResponse: MessageFns<SwapResponse> = {
  encode(message: SwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.amountOut !== "") {
      writer.uint32(18).string(message.amountOut);
    }
    if (message.outputToken !== undefined) {
      ChainToken.encode(message.outputToken, writer.uint32(26).fork()).join();
    }
    for (const v of message.pathSteps) {
      Step.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.amountIn !== "") {
      writer.uint32(58).string(message.amountIn);
    }
    if (message.inputToken !== "") {
      writer.uint32(66).string(message.inputToken);
    }
    if (message.refundAddress !== "") {
      writer.uint32(74).string(message.refundAddress);
    }
    if (message.chainId !== "") {
      writer.uint32(82).string(message.chainId);
    }
    if (message.recipientAddress !== "") {
      writer.uint32(90).string(message.recipientAddress);
    }
    if (message.partnerId !== 0) {
      writer.uint32(96).uint32(message.partnerId);
    }
    if (message.depositAddress !== "") {
      writer.uint32(106).string(message.depositAddress);
    }
    if (message.transactionData !== undefined) {
      TransactionData.encode(message.transactionData, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pathSteps.push(Step.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inputToken = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.refundAddress = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.recipientAddress = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.partnerId = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.depositAddress = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.transactionData = TransactionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapResponse {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
      outputToken: isSet(object.outputToken) ? ChainToken.fromJSON(object.outputToken) : undefined,
      pathSteps: globalThis.Array.isArray(object?.pathSteps) ? object.pathSteps.map((e: any) => Step.fromJSON(e)) : [],
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      inputToken: isSet(object.inputToken) ? globalThis.String(object.inputToken) : "",
      refundAddress: isSet(object.refundAddress) ? globalThis.String(object.refundAddress) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      recipientAddress: isSet(object.recipientAddress) ? globalThis.String(object.recipientAddress) : "",
      partnerId: isSet(object.partnerId) ? globalThis.Number(object.partnerId) : 0,
      depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
      transactionData: isSet(object.transactionData) ? TransactionData.fromJSON(object.transactionData) : undefined,
    };
  },

  toJSON(message: SwapResponse): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    if (message.outputToken !== undefined) {
      obj.outputToken = ChainToken.toJSON(message.outputToken);
    }
    if (message.pathSteps?.length) {
      obj.pathSteps = message.pathSteps.map((e) => Step.toJSON(e));
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.inputToken !== "") {
      obj.inputToken = message.inputToken;
    }
    if (message.refundAddress !== "") {
      obj.refundAddress = message.refundAddress;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.recipientAddress !== "") {
      obj.recipientAddress = message.recipientAddress;
    }
    if (message.partnerId !== 0) {
      obj.partnerId = Math.round(message.partnerId);
    }
    if (message.depositAddress !== "") {
      obj.depositAddress = message.depositAddress;
    }
    if (message.transactionData !== undefined) {
      obj.transactionData = TransactionData.toJSON(message.transactionData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapResponse>, I>>(base?: I): SwapResponse {
    return SwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapResponse>, I>>(object: I): SwapResponse {
    const message = createBaseSwapResponse();
    message.uuid = object.uuid ?? "";
    message.amountOut = object.amountOut ?? "";
    message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
      ? ChainToken.fromPartial(object.outputToken)
      : undefined;
    message.pathSteps = object.pathSteps?.map((e) => Step.fromPartial(e)) || [];
    message.amountIn = object.amountIn ?? "";
    message.inputToken = object.inputToken ?? "";
    message.refundAddress = object.refundAddress ?? "";
    message.chainId = object.chainId ?? "";
    message.recipientAddress = object.recipientAddress ?? "";
    message.partnerId = object.partnerId ?? 0;
    message.depositAddress = object.depositAddress ?? "";
    message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
      ? TransactionData.fromPartial(object.transactionData)
      : undefined;
    return message;
  },
};

function createBaseEvmTransactionData(): EvmTransactionData {
  return { contractAddress: "", calldata: "", value: "" };
}

export const EvmTransactionData: MessageFns<EvmTransactionData> = {
  encode(message: EvmTransactionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.calldata !== "") {
      writer.uint32(18).string(message.calldata);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvmTransactionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvmTransactionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.calldata = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvmTransactionData {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      calldata: isSet(object.calldata) ? globalThis.String(object.calldata) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EvmTransactionData): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.calldata !== "") {
      obj.calldata = message.calldata;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvmTransactionData>, I>>(base?: I): EvmTransactionData {
    return EvmTransactionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvmTransactionData>, I>>(object: I): EvmTransactionData {
    const message = createBaseEvmTransactionData();
    message.contractAddress = object.contractAddress ?? "";
    message.calldata = object.calldata ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSolanaTransactionData(): SolanaTransactionData {
  return { txMessages: [], blockhash: "", lastValidBlockHeight: 0 };
}

export const SolanaTransactionData: MessageFns<SolanaTransactionData> = {
  encode(message: SolanaTransactionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.txMessages) {
      writer.uint32(10).string(v!);
    }
    if (message.blockhash !== "") {
      writer.uint32(18).string(message.blockhash);
    }
    if (message.lastValidBlockHeight !== 0) {
      writer.uint32(24).uint64(message.lastValidBlockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolanaTransactionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolanaTransactionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txMessages.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockhash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lastValidBlockHeight = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolanaTransactionData {
    return {
      txMessages: globalThis.Array.isArray(object?.txMessages)
        ? object.txMessages.map((e: any) => globalThis.String(e))
        : [],
      blockhash: isSet(object.blockhash) ? globalThis.String(object.blockhash) : "",
      lastValidBlockHeight: isSet(object.lastValidBlockHeight) ? globalThis.Number(object.lastValidBlockHeight) : 0,
    };
  },

  toJSON(message: SolanaTransactionData): unknown {
    const obj: any = {};
    if (message.txMessages?.length) {
      obj.txMessages = message.txMessages;
    }
    if (message.blockhash !== "") {
      obj.blockhash = message.blockhash;
    }
    if (message.lastValidBlockHeight !== 0) {
      obj.lastValidBlockHeight = Math.round(message.lastValidBlockHeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolanaTransactionData>, I>>(base?: I): SolanaTransactionData {
    return SolanaTransactionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolanaTransactionData>, I>>(object: I): SolanaTransactionData {
    const message = createBaseSolanaTransactionData();
    message.txMessages = object.txMessages?.map((e) => e) || [];
    message.blockhash = object.blockhash ?? "";
    message.lastValidBlockHeight = object.lastValidBlockHeight ?? 0;
    return message;
  },
};

function createBaseSuiTransactionData(): SuiTransactionData {
  return { from: "", to: "", data: "", value: "" };
}

export const SuiTransactionData: MessageFns<SuiTransactionData> = {
  encode(message: SuiTransactionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuiTransactionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuiTransactionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuiTransactionData {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SuiTransactionData): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SuiTransactionData>, I>>(base?: I): SuiTransactionData {
    return SuiTransactionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SuiTransactionData>, I>>(object: I): SuiTransactionData {
    const message = createBaseSuiTransactionData();
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.data = object.data ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseXploreRequest(): XploreRequest {
  return {
    inputToken: undefined,
    outputToken: undefined,
    amountIn: "",
    amountOutMin: "",
    slippageTolerancePercent: 0,
    recipientAddress: "",
    senderAddress: "",
    exactOut: false,
    timeoutMs: 0,
    generateDepositAddress: false,
  };
}

export const XploreRequest: MessageFns<XploreRequest> = {
  encode(message: XploreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputToken !== undefined) {
      ChainToken.encode(message.inputToken, writer.uint32(10).fork()).join();
    }
    if (message.outputToken !== undefined) {
      ChainToken.encode(message.outputToken, writer.uint32(18).fork()).join();
    }
    if (message.amountIn !== "") {
      writer.uint32(26).string(message.amountIn);
    }
    if (message.amountOutMin !== "") {
      writer.uint32(34).string(message.amountOutMin);
    }
    if (message.slippageTolerancePercent !== 0) {
      writer.uint32(40).uint64(message.slippageTolerancePercent);
    }
    if (message.recipientAddress !== "") {
      writer.uint32(50).string(message.recipientAddress);
    }
    if (message.senderAddress !== "") {
      writer.uint32(58).string(message.senderAddress);
    }
    if (message.exactOut !== false) {
      writer.uint32(64).bool(message.exactOut);
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(72).int64(message.timeoutMs);
    }
    if (message.generateDepositAddress !== false) {
      writer.uint32(80).bool(message.generateDepositAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): XploreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXploreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amountOutMin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.slippageTolerancePercent = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.recipientAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.senderAddress = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.exactOut = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.timeoutMs = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.generateDepositAddress = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XploreRequest {
    return {
      inputToken: isSet(object.inputToken) ? ChainToken.fromJSON(object.inputToken) : undefined,
      outputToken: isSet(object.outputToken) ? ChainToken.fromJSON(object.outputToken) : undefined,
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      amountOutMin: isSet(object.amountOutMin) ? globalThis.String(object.amountOutMin) : "",
      slippageTolerancePercent: isSet(object.slippageTolerancePercent)
        ? globalThis.Number(object.slippageTolerancePercent)
        : 0,
      recipientAddress: isSet(object.recipientAddress) ? globalThis.String(object.recipientAddress) : "",
      senderAddress: isSet(object.senderAddress) ? globalThis.String(object.senderAddress) : "",
      exactOut: isSet(object.exactOut) ? globalThis.Boolean(object.exactOut) : false,
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
      generateDepositAddress: isSet(object.generateDepositAddress)
        ? globalThis.Boolean(object.generateDepositAddress)
        : false,
    };
  },

  toJSON(message: XploreRequest): unknown {
    const obj: any = {};
    if (message.inputToken !== undefined) {
      obj.inputToken = ChainToken.toJSON(message.inputToken);
    }
    if (message.outputToken !== undefined) {
      obj.outputToken = ChainToken.toJSON(message.outputToken);
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.amountOutMin !== "") {
      obj.amountOutMin = message.amountOutMin;
    }
    if (message.slippageTolerancePercent !== 0) {
      obj.slippageTolerancePercent = Math.round(message.slippageTolerancePercent);
    }
    if (message.recipientAddress !== "") {
      obj.recipientAddress = message.recipientAddress;
    }
    if (message.senderAddress !== "") {
      obj.senderAddress = message.senderAddress;
    }
    if (message.exactOut !== false) {
      obj.exactOut = message.exactOut;
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    if (message.generateDepositAddress !== false) {
      obj.generateDepositAddress = message.generateDepositAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<XploreRequest>, I>>(base?: I): XploreRequest {
    return XploreRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<XploreRequest>, I>>(object: I): XploreRequest {
    const message = createBaseXploreRequest();
    message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
      ? ChainToken.fromPartial(object.inputToken)
      : undefined;
    message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
      ? ChainToken.fromPartial(object.outputToken)
      : undefined;
    message.amountIn = object.amountIn ?? "";
    message.amountOutMin = object.amountOutMin ?? "";
    message.slippageTolerancePercent = object.slippageTolerancePercent ?? 0;
    message.recipientAddress = object.recipientAddress ?? "";
    message.senderAddress = object.senderAddress ?? "";
    message.exactOut = object.exactOut ?? false;
    message.timeoutMs = object.timeoutMs ?? 0;
    message.generateDepositAddress = object.generateDepositAddress ?? false;
    return message;
  },
};

function createBaseAPISwapResponse(): APISwapResponse {
  return {
    uuid: "",
    amountIn: "",
    amountOut: "",
    outputToken: undefined,
    pathSteps: [],
    depositAddress: "",
    transactionData: undefined,
  };
}

export const APISwapResponse: MessageFns<APISwapResponse> = {
  encode(message: APISwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.amountIn !== "") {
      writer.uint32(18).string(message.amountIn);
    }
    if (message.amountOut !== "") {
      writer.uint32(26).string(message.amountOut);
    }
    if (message.outputToken !== undefined) {
      ChainToken.encode(message.outputToken, writer.uint32(34).fork()).join();
    }
    for (const v of message.pathSteps) {
      Step.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.depositAddress !== "") {
      writer.uint32(50).string(message.depositAddress);
    }
    if (message.transactionData !== undefined) {
      TransactionData.encode(message.transactionData, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): APISwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAPISwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pathSteps.push(Step.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.depositAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.transactionData = TransactionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): APISwapResponse {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
      outputToken: isSet(object.outputToken) ? ChainToken.fromJSON(object.outputToken) : undefined,
      pathSteps: globalThis.Array.isArray(object?.pathSteps) ? object.pathSteps.map((e: any) => Step.fromJSON(e)) : [],
      depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
      transactionData: isSet(object.transactionData) ? TransactionData.fromJSON(object.transactionData) : undefined,
    };
  },

  toJSON(message: APISwapResponse): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    if (message.outputToken !== undefined) {
      obj.outputToken = ChainToken.toJSON(message.outputToken);
    }
    if (message.pathSteps?.length) {
      obj.pathSteps = message.pathSteps.map((e) => Step.toJSON(e));
    }
    if (message.depositAddress !== "") {
      obj.depositAddress = message.depositAddress;
    }
    if (message.transactionData !== undefined) {
      obj.transactionData = TransactionData.toJSON(message.transactionData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<APISwapResponse>, I>>(base?: I): APISwapResponse {
    return APISwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<APISwapResponse>, I>>(object: I): APISwapResponse {
    const message = createBaseAPISwapResponse();
    message.uuid = object.uuid ?? "";
    message.amountIn = object.amountIn ?? "";
    message.amountOut = object.amountOut ?? "";
    message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
      ? ChainToken.fromPartial(object.outputToken)
      : undefined;
    message.pathSteps = object.pathSteps?.map((e) => Step.fromPartial(e)) || [];
    message.depositAddress = object.depositAddress ?? "";
    message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
      ? TransactionData.fromPartial(object.transactionData)
      : undefined;
    return message;
  },
};

function createBaseStep(): Step {
  return { inputToken: undefined, amountIn: "", protocolName: "", outputToken: undefined, amountOut: "" };
}

export const Step: MessageFns<Step> = {
  encode(message: Step, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputToken !== undefined) {
      ChainToken.encode(message.inputToken, writer.uint32(10).fork()).join();
    }
    if (message.amountIn !== "") {
      writer.uint32(18).string(message.amountIn);
    }
    if (message.protocolName !== "") {
      writer.uint32(26).string(message.protocolName);
    }
    if (message.outputToken !== undefined) {
      ChainToken.encode(message.outputToken, writer.uint32(34).fork()).join();
    }
    if (message.amountOut !== "") {
      writer.uint32(42).string(message.amountOut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Step {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.protocolName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Step {
    return {
      inputToken: isSet(object.inputToken) ? ChainToken.fromJSON(object.inputToken) : undefined,
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      protocolName: isSet(object.protocolName) ? globalThis.String(object.protocolName) : "",
      outputToken: isSet(object.outputToken) ? ChainToken.fromJSON(object.outputToken) : undefined,
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
    };
  },

  toJSON(message: Step): unknown {
    const obj: any = {};
    if (message.inputToken !== undefined) {
      obj.inputToken = ChainToken.toJSON(message.inputToken);
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.protocolName !== "") {
      obj.protocolName = message.protocolName;
    }
    if (message.outputToken !== undefined) {
      obj.outputToken = ChainToken.toJSON(message.outputToken);
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Step>, I>>(base?: I): Step {
    return Step.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Step>, I>>(object: I): Step {
    const message = createBaseStep();
    message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
      ? ChainToken.fromPartial(object.inputToken)
      : undefined;
    message.amountIn = object.amountIn ?? "";
    message.protocolName = object.protocolName ?? "";
    message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
      ? ChainToken.fromPartial(object.outputToken)
      : undefined;
    message.amountOut = object.amountOut ?? "";
    return message;
  },
};

function createBaseRouteStep(): RouteStep {
  return {
    nodeId: "",
    inputToken: undefined,
    outputToken: undefined,
    amountIn: "",
    amountOut: "",
    transactionData: undefined,
  };
}

export const RouteStep: MessageFns<RouteStep> = {
  encode(message: RouteStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.inputToken !== undefined) {
      ChainToken.encode(message.inputToken, writer.uint32(18).fork()).join();
    }
    if (message.outputToken !== undefined) {
      ChainToken.encode(message.outputToken, writer.uint32(26).fork()).join();
    }
    if (message.amountIn !== "") {
      writer.uint32(34).string(message.amountIn);
    }
    if (message.amountOut !== "") {
      writer.uint32(42).string(message.amountOut);
    }
    if (message.transactionData !== undefined) {
      TransactionData.encode(message.transactionData, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputToken = ChainToken.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.transactionData = TransactionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteStep {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      inputToken: isSet(object.inputToken) ? ChainToken.fromJSON(object.inputToken) : undefined,
      outputToken: isSet(object.outputToken) ? ChainToken.fromJSON(object.outputToken) : undefined,
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
      transactionData: isSet(object.transactionData) ? TransactionData.fromJSON(object.transactionData) : undefined,
    };
  },

  toJSON(message: RouteStep): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.inputToken !== undefined) {
      obj.inputToken = ChainToken.toJSON(message.inputToken);
    }
    if (message.outputToken !== undefined) {
      obj.outputToken = ChainToken.toJSON(message.outputToken);
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    if (message.transactionData !== undefined) {
      obj.transactionData = TransactionData.toJSON(message.transactionData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteStep>, I>>(base?: I): RouteStep {
    return RouteStep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteStep>, I>>(object: I): RouteStep {
    const message = createBaseRouteStep();
    message.nodeId = object.nodeId ?? "";
    message.inputToken = (object.inputToken !== undefined && object.inputToken !== null)
      ? ChainToken.fromPartial(object.inputToken)
      : undefined;
    message.outputToken = (object.outputToken !== undefined && object.outputToken !== null)
      ? ChainToken.fromPartial(object.outputToken)
      : undefined;
    message.amountIn = object.amountIn ?? "";
    message.amountOut = object.amountOut ?? "";
    message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
      ? TransactionData.fromPartial(object.transactionData)
      : undefined;
    return message;
  },
};

function createBaseXploreResponse(): XploreResponse {
  return {
    amountIn: "",
    amountOut: "",
    priceImpact: 0,
    route: [],
    executionTime: 0,
    gasEstimate: 0,
    depositAddress: "",
    value: "",
    transactionData: undefined,
  };
}

export const XploreResponse: MessageFns<XploreResponse> = {
  encode(message: XploreResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amountIn !== "") {
      writer.uint32(10).string(message.amountIn);
    }
    if (message.amountOut !== "") {
      writer.uint32(18).string(message.amountOut);
    }
    if (message.priceImpact !== 0) {
      writer.uint32(25).double(message.priceImpact);
    }
    for (const v of message.route) {
      RouteStep.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.executionTime !== 0) {
      writer.uint32(41).double(message.executionTime);
    }
    if (message.gasEstimate !== 0) {
      writer.uint32(48).int64(message.gasEstimate);
    }
    if (message.depositAddress !== "") {
      writer.uint32(58).string(message.depositAddress);
    }
    if (message.value !== "") {
      writer.uint32(66).string(message.value);
    }
    if (message.transactionData !== undefined) {
      TransactionData.encode(message.transactionData, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): XploreResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXploreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.priceImpact = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.route.push(RouteStep.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.executionTime = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gasEstimate = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.depositAddress = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.transactionData = TransactionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XploreResponse {
    return {
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
      priceImpact: isSet(object.priceImpact) ? globalThis.Number(object.priceImpact) : 0,
      route: globalThis.Array.isArray(object?.route) ? object.route.map((e: any) => RouteStep.fromJSON(e)) : [],
      executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : 0,
      gasEstimate: isSet(object.gasEstimate) ? globalThis.Number(object.gasEstimate) : 0,
      depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      transactionData: isSet(object.transactionData) ? TransactionData.fromJSON(object.transactionData) : undefined,
    };
  },

  toJSON(message: XploreResponse): unknown {
    const obj: any = {};
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    if (message.priceImpact !== 0) {
      obj.priceImpact = message.priceImpact;
    }
    if (message.route?.length) {
      obj.route = message.route.map((e) => RouteStep.toJSON(e));
    }
    if (message.executionTime !== 0) {
      obj.executionTime = message.executionTime;
    }
    if (message.gasEstimate !== 0) {
      obj.gasEstimate = Math.round(message.gasEstimate);
    }
    if (message.depositAddress !== "") {
      obj.depositAddress = message.depositAddress;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.transactionData !== undefined) {
      obj.transactionData = TransactionData.toJSON(message.transactionData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<XploreResponse>, I>>(base?: I): XploreResponse {
    return XploreResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<XploreResponse>, I>>(object: I): XploreResponse {
    const message = createBaseXploreResponse();
    message.amountIn = object.amountIn ?? "";
    message.amountOut = object.amountOut ?? "";
    message.priceImpact = object.priceImpact ?? 0;
    message.route = object.route?.map((e) => RouteStep.fromPartial(e)) || [];
    message.executionTime = object.executionTime ?? 0;
    message.gasEstimate = object.gasEstimate ?? 0;
    message.depositAddress = object.depositAddress ?? "";
    message.value = object.value ?? "";
    message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
      ? TransactionData.fromPartial(object.transactionData)
      : undefined;
    return message;
  },
};

export type AggregatorService = typeof AggregatorService;
export const AggregatorService = {
  aggregateCall: {
    path: "/xplore.Aggregator/AggregateCall",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: XploreRequest) => Buffer.from(XploreRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => XploreRequest.decode(value),
    responseSerialize: (value: XploreResponse) => Buffer.from(XploreResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => XploreResponse.decode(value),
  },
  getTransactionRecord: {
    path: "/xplore.Aggregator/GetTransactionRecord",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransactionRecordRequest) => Buffer.from(TransactionRecordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransactionRecordRequest.decode(value),
    responseSerialize: (value: TransactionRecord) => Buffer.from(TransactionRecord.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionRecord.decode(value),
  },
} as const;

export interface AggregatorServer extends UntypedServiceImplementation {
  aggregateCall: handleUnaryCall<XploreRequest, XploreResponse>;
  getTransactionRecord: handleUnaryCall<TransactionRecordRequest, TransactionRecord>;
}

export interface AggregatorClient extends Client {
  aggregateCall(
    request: XploreRequest,
    callback: (error: ServiceError | null, response: XploreResponse) => void,
  ): ClientUnaryCall;
  aggregateCall(
    request: XploreRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: XploreResponse) => void,
  ): ClientUnaryCall;
  aggregateCall(
    request: XploreRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: XploreResponse) => void,
  ): ClientUnaryCall;
  getTransactionRecord(
    request: TransactionRecordRequest,
    callback: (error: ServiceError | null, response: TransactionRecord) => void,
  ): ClientUnaryCall;
  getTransactionRecord(
    request: TransactionRecordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionRecord) => void,
  ): ClientUnaryCall;
  getTransactionRecord(
    request: TransactionRecordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionRecord) => void,
  ): ClientUnaryCall;
}

export const AggregatorClient = makeGenericClientConstructor(AggregatorService, "xplore.Aggregator") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AggregatorClient;
  service: typeof AggregatorService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
